UnB - Software Básico 2/2015 - JVM

======

Autores:


	- Abílio E. C. de Oliveira 	10/0006132

	- Marcus da Silva Ferreira	10/0056881

	- Michael Rodrigues 		09/0126432



Compilação
======

É dado uma makefile para geração dos binários. Pelo terminal, acesse a pasta referente a este LEIAME.txt e execute ‘make’.
Um binário será gerado:

	- JVM.exe (o interpretador de bytecode Java)

Caso não deseje utilizar o makefile, será exigido executar a seguinte linha de comando:
	
	gcc -std=c99 src/Common/common.c src/Util/util.c src/ClassLoader/Class/class.c src/ClassLoader/Class/AttributeInfo/attributeinfo.c src/ClassLoader/Class/ConstantPool/constantpool.c src/ClassLoader/Class/FieldInfo/fieldinfo.c src/ClassLoader/Class/MethodInfo/methodinfo.c src/ClassLoader/classloader.c src/JVM/maquina/maquina.c src/JVM/main.c -o JVM.exe


Execução
======
Para executar a JVM, se dirija ao terminal e execute './JVM.exe <ClassName> [opções]’

As opções de linhas de comando disponíveis para a execução da JVM podem ser acessadas executando:

	./JVM.exe --help


Organização
=======
Segue a estrutura de pastas e seus significados
	
	./ -> pasta que contem os arquivos do projeto (aqui serão gerados os executáveis)
		
		./documentação -> documentação Doxygen
			
			./html -> arquivos html da documentação Doxygen

		./java -> pasta essencial contendo os .class básicos para o bom funcionamento da JVM.
		
		./src -> códigos fonte
		
			./Common -> Modulo com estruturas comuns a todos os módulos e variáveis globais
			
			./Util   -> Modulo com funções e estruturas para lidar com rotinas de I/O

			./JVM    -> Modulo contendo o 'int main(int argc, char** argv)' do interpretador Java (JVM)

				./maquina -> Submódulo contendo as entidades responsáveis por administrar a execução da JVM

			./ClassLoader -> Modulo que lida com o carregamento em memória de um '.class' de forma estruturada
			
				./Class -> Modulo que define a estrutura de um ponto class e fornece a funcionalidade necessária para carregar um .class para memória
				
					./AttributeInfo -> Modulo que define a estrutura de um AttributeInfo e as funções para tratar tal estrutura 
				
					./ConstantPool -> Modulo que define a estrutura de um ConstantPool e as funções para tratar tal estrutura
	
					./FieldInfo -> Modulo que define a estrutura de um FieldInfo e as funções para tratar tal estrutura

					./MethodInfo -> Modulo que define a estrutura de um MethodInfo e as funções para tratat tal estrutura

Observacoes
=======
Tentamos organizar este projeto num padrão orientado a objetos. Cada módulo deve possuir um variado numero de pastas, e ao menos dois arquivos que indiquem suas estruturas e funções relacionadas. Geralmente:
	
	- X.h -> define as estruturas e funções de tal modulo; todo módulo possui uma struct associada

	- X.c -> implementa as funções de tal modulo (com o modificador de acesso estático), de forma que as funções visíveis globalmente são encapsuladas na struct do módulo

	- private.c -> funções somente visíveis ao modulo X

	- subpastas -> submódulos

Utilizando ponteiros para funções em estruturas, nos possibilitou simular uma falsa orientação a objeto, visando facilitar a manutenabilidade da aplicação e também visando uma melhor escalabilidade da mesma
--
(c)



	